import { constants } from "@clerk/backend";
import { NextResponse } from "next/server";
import { isRedirect, mergeResponses, paths, setHeader, stringifyHeaders } from "../utils";
import { withLogger } from "../utils/debugLogger";
import { authenticateRequest, handleInterstitialState, handleUnknownState } from "./authenticateRequest";
import { SECRET_KEY } from "./clerkClient";
import { DEV_BROWSER_JWT_MARKER, setDevBrowserJWTInURL } from "./devBrowser";
import { receivedRequestForIgnoredRoute } from "./errors";
import { redirectToSignIn } from "./redirect";
import {
  apiEndpointUnauthorizedNextResponse,
  decorateRequest,
  isCrossOrigin,
  isDevelopmentFromApiKey,
  setRequestHeadersOnNextResponse
} from "./utils";
const INFINITE_REDIRECTION_LOOP_COOKIE = "__clerk_redirection_loop";
const DEFAULT_CONFIG_MATCHER = ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"];
const DEFAULT_IGNORED_ROUTES = ["/((?!api|trpc))(_next|.+\\..+)(.*)"];
const DEFAULT_API_ROUTES = ["/api/(.*)", "/trpc/(.*)"];
const authMiddleware = (...args) => {
  const [params = {}] = args;
  const { beforeAuth, afterAuth, publicRoutes, ignoredRoutes, apiRoutes, ...options } = params;
  const isIgnoredRoute = createRouteMatcher(ignoredRoutes || DEFAULT_IGNORED_ROUTES);
  const isPublicRoute = createRouteMatcher(withDefaultPublicRoutes(publicRoutes));
  const isApiRoute = createApiRoutes(apiRoutes);
  const defaultAfterAuth = createDefaultAfterAuth(isPublicRoute, isApiRoute);
  return withLogger("authMiddleware", (logger) => async (req, evt) => {
    if (options.debug) {
      logger.enable();
    }
    logger.debug("URL debug", { url: req.nextUrl.href, method: req.method, headers: stringifyHeaders(req.headers) });
    logger.debug("Options debug", { ...options, beforeAuth: !!beforeAuth, afterAuth: !!afterAuth });
    if (isIgnoredRoute(req)) {
      logger.debug({ isIgnoredRoute: true });
      console.warn(receivedRequestForIgnoredRoute(req.nextUrl.href, JSON.stringify(DEFAULT_CONFIG_MATCHER)));
      return setHeader(NextResponse.next(), constants.Headers.AuthReason, "ignored-route");
    }
    const beforeAuthRes = await (beforeAuth && beforeAuth(req, evt));
    if (beforeAuthRes === false) {
      logger.debug("Before auth returned false, skipping");
      return setHeader(NextResponse.next(), constants.Headers.AuthReason, "skip");
    } else if (beforeAuthRes && isRedirect(beforeAuthRes)) {
      logger.debug("Before auth returned redirect, following redirect");
      return setHeader(beforeAuthRes, constants.Headers.AuthReason, "redirect");
    }
    const requestState = await authenticateRequest(req, options);
    if (requestState.isUnknown) {
      logger.debug("authenticateRequest state is unknown", requestState);
      return handleUnknownState(requestState);
    } else if (requestState.isInterstitial && isApiRoute(req)) {
      logger.debug("authenticateRequest state is interstitial in an API route", requestState);
      return handleUnknownState(requestState);
    } else if (requestState.isInterstitial) {
      logger.debug("authenticateRequest state is interstitial", requestState);
      const res = handleInterstitialState(requestState, options);
      return assertInfiniteRedirectionLoop(req, res);
    }
    const auth = Object.assign(requestState.toAuth(), {
      isPublicRoute: isPublicRoute(req),
      isApiRoute: isApiRoute(req)
    });
    logger.debug(() => ({ auth: JSON.stringify(auth), debug: auth.debug() }));
    const afterAuthRes = await (afterAuth || defaultAfterAuth)(auth, req, evt);
    const finalRes = mergeResponses(beforeAuthRes, afterAuthRes) || NextResponse.next();
    logger.debug(() => ({ mergedHeaders: stringifyHeaders(finalRes.headers) }));
    if (isRedirect(finalRes)) {
      logger.debug("Final response is redirect, following redirect");
      const res = setHeader(finalRes, constants.Headers.AuthReason, "redirect");
      return appendDevBrowserOnCrossOrigin(req, res);
    }
    if (options.debug) {
      setRequestHeadersOnNextResponse(finalRes, req, { [constants.Headers.EnableDebug]: "true" });
      logger.debug(`Added ${constants.Headers.EnableDebug} on request`);
    }
    return decorateRequest(req, finalRes, requestState);
  });
};
const createRouteMatcher = (routes) => {
  if (typeof routes === "function") {
    return (req) => routes(req);
  }
  const routePatterns = [routes || ""].flat().filter(Boolean);
  const matchers = precomputePathRegex(routePatterns);
  return (req) => matchers.some((matcher) => matcher.test(req.nextUrl.pathname));
};
const createDefaultAfterAuth = (isPublicRoute, isApiRoute) => {
  return (auth, req) => {
    if (!auth.userId && !isPublicRoute(req) && isApiRoute(req)) {
      return apiEndpointUnauthorizedNextResponse();
    } else if (!auth.userId && !isPublicRoute(req)) {
      return redirectToSignIn({ returnBackUrl: req.url });
    }
    return NextResponse.next();
  };
};
const precomputePathRegex = (patterns) => {
  return patterns.map((pattern) => pattern instanceof RegExp ? pattern : paths.toRegexp(pattern));
};
const matchRoutesStartingWith = (path) => {
  path = path.replace(/\/$/, "");
  return new RegExp(`^${path}(/.*)?$`);
};
const withDefaultPublicRoutes = (publicRoutes) => {
  if (typeof publicRoutes === "function") {
    return publicRoutes;
  }
  const routes = [publicRoutes || ""].flat().filter(Boolean);
  const signInUrl = process.env.NEXT_PUBLIC_CLERK_SIGN_IN_URL || "";
  if (signInUrl) {
    routes.push(matchRoutesStartingWith(signInUrl));
  }
  const signUpUrl = process.env.NEXT_PUBLIC_CLERK_SIGN_UP_URL || "";
  if (signUpUrl) {
    routes.push(matchRoutesStartingWith(signUpUrl));
  }
  return routes;
};
const appendDevBrowserOnCrossOrigin = (req, res) => {
  const location = res.headers.get("location");
  const shouldAppendDevBrowser = res.headers.get(constants.Headers.ClerkRedirectTo) === "true";
  if (shouldAppendDevBrowser && !!location && isDevelopmentFromApiKey(SECRET_KEY) && isCrossOrigin(req.url, location)) {
    const dbJwt = req.cookies.get(DEV_BROWSER_JWT_MARKER)?.value;
    const urlWithDevBrowser = setDevBrowserJWTInURL(location, dbJwt);
    return NextResponse.redirect(urlWithDevBrowser, res);
  }
  return res;
};
const createApiRoutes = (apiRoutes) => {
  if (apiRoutes) {
    return createRouteMatcher(apiRoutes);
  }
  const isDefaultApiRoute = createRouteMatcher(DEFAULT_API_ROUTES);
  return (req) => isDefaultApiRoute(req) || isRequestMethodIndicatingApiRoute(req) || isRequestContentTypeJson(req);
};
const isRequestContentTypeJson = (req) => {
  const requestContentType = req.headers.get(constants.Headers.ContentType);
  return requestContentType === constants.ContentTypes.Json;
};
const isRequestMethodIndicatingApiRoute = (req) => {
  const requestMethod = req.method.toLowerCase();
  return !["get", "head", "options"].includes(requestMethod);
};
const assertInfiniteRedirectionLoop = (req, res) => {
  if (!isDevelopmentFromApiKey(SECRET_KEY)) {
    return res;
  }
  const infiniteRedirectsCounter = Number(req.cookies.get(INFINITE_REDIRECTION_LOOP_COOKIE)?.value) || 0;
  if (infiniteRedirectsCounter === 6) {
    throw new Error(INFINITE_REDIRECTION_LOOP_ERROR_MESSAGE);
  }
  if (req.headers.get("referer") === req.url) {
    res.cookies.set({
      name: INFINITE_REDIRECTION_LOOP_COOKIE,
      value: `${infiniteRedirectsCounter + 1}`,
      maxAge: 3
    });
  }
  return res;
};
const INFINITE_REDIRECTION_LOOP_ERROR_MESSAGE = `Clerk: Infinite redirect loop detected. That usually means that we were not able to determine the auth state for this request. A list of common causes and solutions follows.

Reason 1:
Your server's system clock is inaccurate. Clerk will continuously try to issue new tokens, as the existing ones will be treated as "expired" due to clock skew.
How to resolve:
-> Make sure your system's clock is set to the correct time (e.g. turn off and on automatic time synchronization).

Reason 2:
You changed Clerk instance keys (Publishable Key, Secret Key).
How to resolve:
-> Make sure you have cleared your browser's application data and cookies everytime you change keys.

Reason 3:
A bug that may have already been fixed in the latest version of Clerk NextJS package.
How to resolve:
-> Make sure you are using the latest version of '@clerk/nextjs' and 'next'.
  `;
export {
  DEFAULT_API_ROUTES,
  DEFAULT_CONFIG_MATCHER,
  DEFAULT_IGNORED_ROUTES,
  authMiddleware,
  createRouteMatcher
};
//# sourceMappingURL=authMiddleware.js.map